'''
Created on Jun 28, 2011

@package: Newscoop
@copyright: 2011 Sourcefabric o.p.s.
@license: http://www.gnu.org/licenses/gpl-3.0.txt
@author: Gabriel Nistor

Provides the URI request path handler.
'''
from _pyio import StringIO
from ally.core.impl.node import NodeModel
from ally.core.internationalization import msg as _
from ally.core.spec.codes import RESOURCE_NOT_FOUND, RESOURCE_FOUND
from ally.core.spec.resources import Converter, Path, ResourcesManager
from ally.core.spec.server import Request, Response, Processor, ProcessorsChain, \
    RequestResource, ResponseFormat, EncoderPath
from ally.core.util import injected
import logging

# --------------------------------------------------------------------

log = logging.getLogger(__name__)

# --------------------------------------------------------------------

@injected
class URIHandler(Processor):
    '''
    Implementation for a processor that provides the URI conversion to a resource path.
    '''
    
    resourcesManager = ResourcesManager
    # The resources manager that will provide the path to the resource node.
    converter = Converter
    # The converter to be used in handling the path.
    domain = str
    # The path domain something like "http://localhost/".
    separatorPath = '/'
    # The path separator.
    separatorExtension = '.'
    # The extension separator.
    separatorQuery = '?'
    # The query parameters separator.
    separatorParam = '&'
    # The separator for parameters inside a query.
    separatorValue = '='
    # The separator used in parameter to separate name from value.
    separatorList = ','
    # The separator used in defining a list of values.


    def process(self, request, response, chain):
        '''
        @see: Processor.process
        '''
        assert isinstance(chain, ProcessorsChain), 'Invalid processors chain %s' % chain
        if isinstance(request, Request) and isinstance(response, Response):
            requestPath = request.requestPath
            if len(self.domain) > 0 and requestPath.startswith(self.domain):
                requestPath = requestPath[len(self.domain):]
            i = requestPath.find(self.separatorQuery)
            if i >= 0:
                query = requestPath[i + 1:].strip()
                requestPath = requestPath[:i]
            else:
                query = None
            paths = requestPath.split(self.separatorPath)
            i = paths[-1].rfind(self.separatorExtension)
            if i < 0:
                extension = None
            else:
                extension = paths[-1][i + 1:].lower()
                paths[-1] = paths[-1][0:i]
            paths = [p for p in paths if len(p) != 0]
            params = []
            if query is not None and len(query) > 0:
                for param in (param.split(self.separatorValue) for param in query.split(self.separatorParam)):
                    if len(param) > 1:
                        listValue = param[1].split(self.separatorList)
                        for value in listValue:
                            params.append((param[0], value))
                    else:
                        params.append((param[0], None))
            path = self.resourcesManager.findResourcePath(self.converter, paths)
            assert isinstance(path, Path)
            assert isinstance(response, Response)
            if path.node is None:
                # we stop the chain processing
                response.setCode(RESOURCE_NOT_FOUND, _('Cannot find resources for path'))
                log.debug('Could not locate resource for %s', request.requestPath)
            else:
                response.setCode(RESOURCE_FOUND)
                requestResource = RequestResource(request, path, params)
                response = ResponseFormat(response, URIEncoderPath(self, extension), extension)
                log.debug('Successfully found resource for path %s with extension %s', \
                          request.requestPath, extension)
                chain.process(requestResource, response)
            return
        chain.process(request, response)
            
# --------------------------------------------------------------------

class URIEncoderPath(EncoderPath):
    '''
    Provides encoding for the URI paths generated by the URI processor.
    '''
    
    def __init__(self, uri, ext):
        '''
        @param uri: URI
            The URI processor of the encoder path.
        @param ext: string
            The extension to use on the encoded paths.
        '''
        assert isinstance(uri, URIHandler), 'Invalid URI handler %s' % uri
        assert ext is None or isinstance(ext, str), 'Invalid extension %s' % ext
        self._uri = uri
        self._ext = ext

    def encode(self, path):
        '''
        @see: EncoderPath.encode
        '''
        assert isinstance(path, Path), 'Invalid path %s' % path
        uri = self._uri
        assert isinstance(uri, URIHandler)
        full = StringIO()
        full.write(uri.domain)
        full.write(uri.separatorPath.join(path.asPaths(uri.converter)))
        if isinstance(path.node, NodeModel):
            full.write(uri.separatorPath)
        if self._ext is not None:
            full.write(uri.separatorExtension)
            full.write(self._ext)
        return full.getvalue()
 
